<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="site_libs/highlight/textmate.css"
      type="text/css" />
<script src="site_libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>

<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.0/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Course home</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Course information
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="index.html">Course home</a>
    </li>
    <li>
      <a href="syllabus.html">Course Syllabus</a>
    </li>
    <li>
      <a href="course-overview.html">Course Overview</a>
    </li>
    <li>
      <a href="final-project.html">About final project</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Classes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Class-01.html">Class 1: Introduction to decision making</a>
    </li>
    <li>
      <a href="Class-02.html">Class 2: The PrOACT Process</a>
    </li>
    <li>
      <a href="Class-03.html">Class 3: Uncertainty and decision making</a>
    </li>
    <li>
      <a href="Class-04.html">Class 4: Decision trees and nets</a>
    </li>
    <li>
      <a href="Class-05.html">Class 5: Intro to SDM and ARM</a>
    </li>
    <li>
      <a href="Class-06.html">Class 6: Structuring and quantifying objectives</a>
    </li>
    <li>
      <a href="Class-07.html">Class 7: Structuring objectives</a>
    </li>
    <li>
      <a href="Class-08.html">Class 8: Intro to R</a>
    </li>
    <li>
      <a href="Class-09.html">Class 9: Linear Models</a>
    </li>
    <li>
      <a href="Class-10.html">Class 10: LMs and GLMs</a>
    </li>
    <li>
      <a href="Class-11.html">Class 11: Prediction and GLMs</a>
    </li>
    <li>
      <a href="Class-12.html">Class 12: GLMs continued</a>
    </li>
    <li>
      <a href="Class-13.html">Class 13: Poissons</a>
    </li>
    <li>
      <a href="Class-14.html">Class 14: HLMs</a>
    </li>
    <li>
      <a href="Class-15.html">Class 15: HLMs and occupancy</a>
    </li>
    <li>
      <a href="Class-16.html">Class 16: Occupancy continued</a>
    </li>
    <li>
      <a href="Class-17.html">Class 17: Influence diagrams, Sensitivity analyses &amp; N-Mixtures</a>
    </li>
    <li>
      <a href="Class-18.html">Class 18: N-Mixtures &amp; Estimating abundance</a>
    </li>
    <li>
      <a href="Class-19.html">Class 19: Population dynamics and decisions</a>
    </li>
    <li>
      <a href="Class-20.html">Class 20</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Assignments
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="hw-01.html">Homework 1</a>
    </li>
    <li>
      <a href="hw-02.html">Homework 2</a>
    </li>
    <li>
      <a href="hw-03.html">Homework 3</a>
    </li>
    <li>
      <a href="hw-04.html">Homework 4</a>
    </li>
    <li>
      <a href="hw-05.html">Homework 5</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Additional Resources
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="R-tutorials.html">R tutorials</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<p><!--

library(knitr)
rmarkdown::render_site("Class-11.Rmd")# build website

# rmarkdown::render_site()# build webpage
# COPY FILES TO DOCS FOR GITHUB.IO
system(paste("xcopy", 
    '"C:/Users/mcolvin/Documents/Teaching/WFA8433-Natural-Resource-Decision-Making/Course-Materials/_site"', 
    '"C:/Users/mcolvin/Documents/Teaching/WFA8433-Natural-Resource-Decision-Making/Docs"',
    "/E /C /H /R /K /O /Y")) 
  q(save="no") 
--></p>
<p><img src="media/banner-11.jpg" width="95%" /> <!--
Homework 1:  Introduction to basic computing- R
List of preliminary problems to instructor for review
--></p>
<div id="class-11.-lms-and-glms-in-decision-contexts" class="section level1">
<h1>Class 11. LMs and GLMs in Decision Contexts</h1>
<ul>
<li>Supplemental background reading for next class(es): Conroy and Peterson Chapter 5.</li>
<li>Assignment due: None</li>
<li>Group work: Submit a concise summary of your proposed problem by 5 pm Friday. Email to me: <a href="mailto:michael.colvin@msstate.edu">michael.colvin@msstate.edu</a>, only 1 per group needed.</li>
<li>Link to class recording <a href="https://youtu.be/P2yImMMJWao">YouTube</a></li>
<li>Today’s R script <a href="scripts/Class-11.R">Class-11.R</a></li>
</ul>
<div id="objectives" class="section level2">
<h2>Objectives</h2>
<p>By the end of this tutorial you should be able to:</p>
<ol style="list-style-type: decimal">
<li>Understand functions in R</li>
<li>Understand generalized linear models (GLMs)</li>
<li>Understand logit and expit link functions</li>
<li>Further understand interactions in linear models</li>
<li>Predicting outcomes from GLMs</li>
</ol>
</div>
<div id="some-preliminaries" class="section level2">
<h2>Some preliminaries</h2>
<ul>
<li>If you want to play along in class download this zipfile <a href="http://mec685.cfr.msstate.edu/class-11.zip">*.zip</a>.</li>
<li>Be sure to unzip it before trying to use files and such</li>
<li>The file contains the dataset used in class and an R script of all the code.</li>
<li>Once you have it where you want open the R script and be sure to check the working directory <code>getwd()</code> and make sure it is where your folder is.</li>
<li>If your working directory is not correct, you can set it in Rstudio: “Session –&gt; Set Working Directory –&gt; To source file location”. Or you can use the <code>setwd()</code> in the console.</li>
</ul>
</div>
<div id="anatomy-of-a-function" class="section level2">
<h2>Anatomy of a function</h2>
<p>Okay. To this point I have introduced you to a number of object types in R. You then used functions on those objects to get R to do complicated things like fitting a linear model with <code>lm()</code>, extracting coefficients with <code>coef()</code>, or getting residuals with <code>resid()</code>. All three of those functions take an R object and preform some action the returns a value or values. The values returned can be a single <code>value</code>, a <code>vector</code>, a <code>data.frame</code>, or a <code>list</code>. There were a couple of functions that did not take an input. Recall <code>getwd()</code> and <code>objects()</code>?</p>
<p>The basics of a function is R is that you make a function that does something useful. The function can take if needed to perform the function. The general format is</p>
<p><code>myfunction&lt;- function(arg1,arg2)       {       out&lt;- 2*arg1 + arg2 # performs something       return(out) # tells R what to return       }</code></p>
<p>Let’s make a simple function that adds 2 and 6.</p>
<pre class="r"><code>myfunction&lt;- function()
    {
    out&lt;- 2+6
    return(out)
    }</code></pre>
<p>Notice there are no <code>inputs</code> in the function above. This is because we specified everything we needed in the function, therefore no need for additional <code>inputs</code>. Let’s try it out.</p>
<pre class="r"><code>myfunction()</code></pre>
<pre><code>## [1] 8</code></pre>
<p>Neat, it returned the value 8.</p>
<p>Let’s try to make a more sophisticated function, one that returns a vector from 1 to 100!.</p>
<pre class="r"><code>myfunction100&lt;- function()
    {
    out&lt;- 1:100
    return(out)
    }</code></pre>
<p>Let’s see if it works!</p>
<pre class="r"><code>myfunction100()</code></pre>
<pre><code>##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17
##  [18]  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34
##  [35]  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51
##  [52]  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68
##  [69]  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85
##  [86]  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100</code></pre>
<p>Hopefully you are beginning to see how these might be useful! But we can go farther, suppose we want a function that will return a sequence of numbers from a user specified start and stop. Let’s call those x1 and x2 for start and stop respectively. The function to do this will look like.</p>
<pre class="r"><code>myfunctionCustom&lt;- function(x1,x2)
    {
    out&lt;- x1:x2
    return(out)
    }</code></pre>
<p>Let’s see if it works!</p>
<pre class="r"><code>myfunctionCustom(x1=3,x2=55)</code></pre>
<pre><code>##  [1]  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
## [24] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
## [47] 49 50 51 52 53 54 55</code></pre>
<p>Boomtown! it returned a vector from 3 to 55!</p>
<p>Now what happens if we forget to specify an input?</p>
<pre class="r"><code>myfunctionCustom(x1=3)</code></pre>
<p>Well that is no fun.</p>
<p>What happens if we forget to tell the function which input is which?</p>
<pre class="r"><code>myfunctionCustom(3,55)</code></pre>
<pre><code>##  [1]  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
## [24] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
## [47] 49 50 51 52 53 54 55</code></pre>
<p>It did the same things as <code>myfunctionCustom(x1=3,x2=55)</code>. That is because R simply applies the inputs to the same order as the function was created.</p>
<pre class="r"><code>myfunctionCustom(55,3)</code></pre>
<pre><code>##  [1] 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33
## [24] 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10
## [47]  9  8  7  6  5  4  3</code></pre>
<p>Well, that is odd. The vector is not quite I was expecting, it is 55 to 3 rather than 3 to 55! That is because R is automatically assigning 55 to x1 and 3 to x2 becuase that was the original order of the inputs in the function. Lets check to make sure. To see the guts of most functions we can type the function in the console without <code>()</code> like this:</p>
<pre class="r"><code>myfunctionCustom</code></pre>
<pre><code>## function(x1,x2)
##     {
##     out&lt;- x1:x2
##     return(out)
##     }
## &lt;environment: 0x10eaa484&gt;</code></pre>
<p>Yep it has x1 as being the first input and x2 as the second. The input order does not matter if we specify the inputs in the function.</p>
<pre class="r"><code>myfunctionCustom(x2=55,x1=3)</code></pre>
<pre><code>##  [1]  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
## [24] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
## [47] 49 50 51 52 53 54 55</code></pre>
<p>Now one last be before we are done with functions. Recall that when we ran <code>myfunctionCustom(x1=3)</code> it did not run and returned an error? That was because we did not specify x2.</p>
<p>In the original function we can specify default values that R will use if there is no value present. For example, let’s set the default values for x1 and x2 in our function to 1 and 100 respectively.</p>
<pre class="r"><code>myfunctionCustom&lt;- function(x1=1,x2=100)
    {
    out&lt;- x1:x2
    return(out)
    }</code></pre>
<p>Now if I do not specify any inputs I will get a vector from 1 to 100.</p>
<pre class="r"><code>myfunctionCustom()</code></pre>
<pre><code>##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17
##  [18]  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34
##  [35]  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51
##  [52]  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68
##  [69]  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85
##  [86]  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100</code></pre>
<p>Or if I only specify x1 as 50 I will get a vector values from 50 to 100.</p>
<pre class="r"><code>myfunctionCustom(x1=50)</code></pre>
<pre><code>##  [1]  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66
## [18]  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83
## [35]  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100</code></pre>
<p>Alternatively I can only specify x2 as 66 and it returns a vector of 1 to 60.</p>
<pre class="r"><code>myfunctionCustom(x2=66)</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
## [24] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
## [47] 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66</code></pre>
<p>Why is knowing how function works important? Well, it will help out immensely when we are dealing with discrete <em>outcomes</em> that result from Bernoulli, Binomial, or Poisson distributions. But first let’s revisit our old friend the linear model that assumes a normal distribution. Recall, the predictive model was:</p>
<p><span class="math display">\[\mu = \beta_0 + \beta_i\cdot X_i \]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(\beta_{0}\)</span> is the model intercept,</li>
<li><span class="math inline">\(\beta_{i}\)</span> is the effect of covariate <span class="math inline">\(i\)</span>,</li>
<li><span class="math inline">\(X_i\)</span> is a matrix of predictor covariates</li>
<li><span class="math inline">\(i\)</span> indexes each covariate.</li>
</ul>
<p>The link the prediction to data using a statistical model to account for uncertainty as:</p>
<p><span class="math display">\[Y_i \sim Normal(\mu,\sigma)\]</span></p>
<ul>
<li><span class="math inline">\(Y_i\)</span> is the observed values</li>
<li><span class="math inline">\(\mu\)</span> is the predicted value</li>
<li><span class="math inline">\(\sigma\)</span> is the standard deviation.</li>
</ul>
</div>
<div id="prediction-interval" class="section level2">
<h2>Prediction interval</h2>
<pre class="r"><code># THIS WILL READ IN THE CSV FILE FROM YOUR WORKING
# DIRECTORY 
damage_dat&lt;- read.csv(&quot;damage-data.csv&quot;) 
head(damage_dat)</code></pre>
<pre><code>##   habitat_area group_size area_damaged
## 1          106         12         20.5
## 2          134         35         45.9
## 3          143         31         46.2
## 4           40         49         25.5
## 5           61         43         15.4
## 6           72         35         16.0</code></pre>
<p>Recall that we rescaled our group sizes so we could view the interaction of group size and area. Let’s do that again and take a look.</p>
<pre class="r"><code># scale group size
damage_dat$group_size_scl&lt;- (damage_dat$group_size-0)/(max(damage_dat$group_size)-0)</code></pre>
<p>Now we can take a look at the plot again.</p>
<pre class="r"><code>plot(area_damaged~habitat_area, damage_dat,
    xlab=&quot;Habitat area (ha)&quot;,
    ylab=&quot;Area damaged (ha)&quot;,
    las=1,
    cex=damage_dat$group_size_scl*2)# double the scale</code></pre>
<p><img src="Class-11_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<p>We go and fit that model again.</p>
<pre class="r"><code>fit&lt;- lm(area_damaged~habitat_area+group_size+habitat_area:group_size,
    data=damage_dat)</code></pre>
<p>Now we can make predictions of possible outcomes using our statistical model. First we need some data to predict outcomes for. When we deal with interactions we generally want to make predictions for all possible combinations of habitat area and group size. The <code>expand.grid()</code> function will do this for us.</p>
<pre class="r"><code>preddat&lt;- expand.grid(
    habitat_area=c(min(damage_dat$habitat_area):max(damage_dat$habitat_area)),
    group_size= c(min(damage_dat$group_size):max(damage_dat$group_size)))</code></pre>
<p>Using the new data.frame <code>preddat</code> we can make 95% prediction intervals. Now these are different than confidence intervals, they are wider.</p>
<pre class="r"><code>predicted&lt;- predict(fit, preddat, 
    interval=&quot;prediction&quot;, 
    level=0.95)</code></pre>
<p>Let’s check and see what kind of object we are dealing with.</p>
<pre class="r"><code>class(predicted)</code></pre>
<pre><code>## [1] &quot;matrix&quot;</code></pre>
<p>What? A matrix? That is not what I was expecting. If we convert the matrix to a data.frame it is easier to deal with because we can use <code>$</code> to get each column rather than <code>[]</code></p>
<pre class="r"><code>predicted&lt;- as.data.frame(predicted)</code></pre>
<p>Now that we have coerced the matrix into a data.frame we can add it to our predicted data.</p>
<pre class="r"><code>preddat$pred&lt;-predicted$fit
preddat$lci_exact&lt;-predicted$lwr
preddat$uci_exact&lt;-predicted$upr</code></pre>
<p>Let’s take a look at them intervals.</p>
<pre class="r"><code>plot(pred~habitat_area, preddat, 
    subset=group_size==3,type=&#39;l&#39;,ylim=c(-20,50))

# exact prediction intervals
points( lci_exact~habitat_area, preddat,
    subset=group_size==3,type=&#39;l&#39;,lty=2)
points( uci_exact~habitat_area, preddat, 
    subset=group_size==3,type=&#39;l&#39;,lty=2)</code></pre>
<p><img src="Class-11_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>We can also approximate prediction intervals with our statisical model.</p>
<p>Recall that:</p>
<p><span class="math display">\[Y_i \sim Normal(\mu,\sigma)\]</span></p>
<p>If we grab our residual standard error and multiply by a critical t-value. A t-value of 2, or 1.96 if you want to be exact is multiplied by the residual standard error gives approximate 95% prediction intervals.</p>
<pre class="r"><code>sigma&lt;- summary(fit)$sigma
preddat$lci_approximate&lt;- preddat$pred-2*sigma
preddat$uci_approximate&lt;-preddat$pred+2*sigma</code></pre>
<p>Let’s take a look and confirm this.</p>
<p>```r plot(pred~habitat_area, preddat, subset=group_size==3,type=‘l’,ylim=c(-20,50))</p>
<p># exact prediction intervals points( lci_exact~habitat_area, preddat, subset=group_size==3,type=‘l’,lty=2) points( uci_exact~habitat_area, preddat, subset=group_size==3,type=‘l’,lty=2)</p>
<p># add approximate prediction intervals points(lci_approximate~habitat_area, preddat, subset=group_size==3,type=‘l’,lty=2,col=‘red’) points(uci_approximate~habitat_area, preddat, subset=group_size==3,type=‘l’,lty=2,col=‘red’) ```</p>
<p><img src="Class-11_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<p>What is up with the difference? Well the difference is in the additional uncertainty around the estimates of the <span class="math inline">\(\beta\)</span>. You can see them using the <code>vcov()</code> function.</p>
<pre class="r"><code>vcov(fit) # var-cov matrix of betas</code></pre>
<pre><code>##                          (Intercept)  habitat_area    group_size
## (Intercept)             14.539116395 -1.300160e-01 -0.3884588626
## habitat_area            -0.130015972  1.346081e-03  0.0035176198
## group_size              -0.388458863  3.517620e-03  0.0130559343
## habitat_area:group_size  0.003556378 -3.789634e-05 -0.0001194418
##                         habitat_area:group_size
## (Intercept)                        3.556378e-03
## habitat_area                      -3.789634e-05
## group_size                        -1.194418e-04
## habitat_area:group_size            1.317165e-06</code></pre>
<p>Now when dealing with a linear model with a normal distribution these uncertainties combine together pretty well. But once you start dealing with discrete distributions prediction intervals are not as clear cut, especially when it comes to uncertainty in the <span class="math inline">\(\beta\)</span>. But one way around it is to randomly sample your data, fit your model, and then make predictions. If you do this many many times you will approximate the prediction interval. The <code>R</code> code below does this for our linear model using a function.</p>
<pre class="r"><code>bootpredata&lt;- data.frame(habitat_area=100, group_size=3)

bootSimFun &lt;- function(preddata,obsdata) 
    {
    bootdat &lt;- obsdata[sample(seq(nrow(obsdata)),# sample your data
        size=nrow(obsdata),# how many samples?
        replace=TRUE),] # sample with replacement
    # fit the model    
    bootfit &lt;- lm(area_damaged~habitat_area+
            group_size+
            habitat_area:group_size,
            data=bootdat)
    # Make predictions
    bootpred &lt;- predict(bootfit,newdata=preddata)
    sigma&lt;- summary(bootfit)$sigma
    # Add uncertainty to prediction 
    out&lt;- rnorm(length(bootpred),bootpred,sigma)
    return(out)
    }</code></pre>
<p>So we can put in our data we want to predict from <code>bootpredata</code> and our observed data <code>damage_dat</code>.</p>
<pre class="r"><code>bootSimFun(preddat=bootpredata, obsdata=damage_dat)</code></pre>
<pre><code>## [1] 10.88663</code></pre>
<p>And we a prediction. Yeah.</p>
<p>If we do this many times, by many I mean 100s of thousands. I only do a few here because it takes a bit of computer time. Using the <code>for()</code> we can loop over each simulation, 1,2,3,…50 and get a simulation. All we need to do is have an object to store our result in and we are good to go.</p>
<pre class="r"><code>nsims&lt;- 50
pred&lt;- vector(length=nsims)
for(i in 1:nsims)
    {
    pred[i]&lt;- bootSimFun(preddata=bootpredata, obsdata=damage_dat)
    }</code></pre>
<p>We can look at the predictions.</p>
<pre class="r"><code>hist(pred)
abline(v=quantile(pred,c(0.025,0.975)),col=&quot;red&quot;,lwd=5)</code></pre>
<p><img src="Class-11_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<p>Let’s compare the exact solution and the bootstrap.</p>
<pre class="r"><code># the exact solution
preddat[preddat$group_size==3 &amp; preddat$habitat_area==100,]</code></pre>
<pre><code>##    habitat_area group_size     pred lci_exact uci_exact lci_approximate
## 64          100          3 12.49266  2.079407  22.90591        2.438405
##    uci_approximate
## 64        22.54691</code></pre>
<p>and the bootstrap solution</p>
<pre class="r"><code>quantile(pred,c(0.025,0.975))</code></pre>
<pre><code>##      2.5%     97.5% 
##  3.916235 22.593093</code></pre>
<p>If you do enough replicates it will get close to the exact solution. For the sake of time the code below is optimized for speed to run many bootstrap replicates. If you have some time to kill try running for 0.5 million replicates.</p>
<p>So what was the point of all this? We have uncertainty associated with the estimates of the coefficients and overall uncertainty. By generating prediction intervals we can estimate the likelihood of an outcome or calculate the risk of an outcome. Long story short the linear model coupled with the statistical model can be used to make predictions and evaluate the likelihood of an outcome. The probability associated with that outcome can be quantified by the linear model and calculated using an exact solution or an approximate solution by simulation. This is all very important for using data to make decisions. This will become useful when we start to look at outcomes that are not continuous, like counts, occupancy, and so on. But also realizing you are probably doing a good enough job with <span class="math inline">\(\sigma\)</span> as your uncertainty.</p>
</div>
<div id="generalized-linear-models" class="section level2">
<h2>Generalized linear models</h2>
<div id="binomial-data" class="section level3">
<h3>Binomial data</h3>
<p>The previous example was a bit odd. When we calculated the prediction intervals were negative in some cases. It seems to me that you should not have a negative amount of habitat damaged as a possible outcome, even if that outcome has a very small probability of happening. Right? Well when you are trying to model proportions or parts of a whole a binomial distribution comes in pretty darn handy. Examples of a binomially distributed value include:</p>
<ul>
<li>Mortalities: number dead:total number</li>
<li>Area damaged: area damaged:total area</li>
<li>Captures: number captured:total number</li>
<li>Sex ratio: number of females:total number, and so on.</li>
</ul>
<p>The gist here is that you have integers that can be viewed as trials and successes or failure. For example if you have 100 critters in a tank and 40 of them survive there were 40 successes and 60 failures. Similarly if there are 100 critters in a plot and you capture 70 of them there were 70 successes and 30 failures.</p>
<p>Now you may be asking yourself why don’t I just calculate the probabilities and go from there? Well, 2 reasons come to mind.</p>
<ol style="list-style-type: decimal">
<li><p>Natural resource data is rarely equal sizes, for example the precision around 5/10 versus 50/100 are very different and it seems a shame to lose that information.</p></li>
<li><p>Many times we need to be able to predict an outcome given an input. For example, if I have 1000 critters, how many might die if we translocate them? The predictions from a binomial are a whole number which makes biological sense.</p></li>
</ol>
<div id="the-data" class="section level4">
<h4>The data</h4>
<p>Here we have a data set of with 4 columns quantifying temperature, what truck was used, number of critters translocated, and the number that survived.</p>
<p>Go ahead and read in the data, assuming it is in your working directory.</p>
<pre class="r"><code>dat&lt;- read.csv(&quot;transport-mortality-data.csv&quot;)</code></pre>
<p>Take a look at the first couple of rows</p>
<pre class="r"><code>head(dat)</code></pre>
<pre><code>##   temperature   truck n_translocated n_survived
## 1         7.3 truck 2            442        140
## 2         9.0 truck 2            587        163
## 3         9.5 truck 2            410        114
## 4         3.3 truck 2            578        159
## 5         4.6 truck 1            461        127
## 6         5.2 truck 2            287         73</code></pre>
</div>
<div id="model" class="section level4">
<h4>model</h4>
<p>The model looks familiar, we have seen the right hand side before, the only new thing we are seeing is the <code>logit()</code> function and p. Well to fit a linear model to value that is bound between 0 and 1 we need to transform those values. The most common way to do that is to take the log of of the odds $logit(p)log() which gives values that vary from about -20 to 20 or so.</p>
<p><span class="math display">\[\text{logit}(p) = \beta_{0}+
    \beta_{1}\cdot\text{Temperature}+
    \beta_{2}\cdot\text{Truck}+
    \beta_{3}\cdot\text{Temperature}\cdot\text{Truck}\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(\beta_{0}\)</span> is the intercept of the linear model<br />
</li>
<li><span class="math inline">\(\beta_{1}\)</span> is the effect of temperature</li>
<li><span class="math inline">\(\beta_{2}\)</span> is the effect of truck</li>
<li><span class="math inline">\(\beta_{3}\)</span> is the interaction of temperature and truck, and</li>
<li><span class="math inline">\(p\)</span> is the predicted survival</li>
</ul>
<p>The statistical model linking the observed data to the linear model is:</p>
<p><span class="math display">\[\text{Number Survived}\sim Binomial(\text{Number Translocated},p)\]</span></p>
<p>where,</p>
<ul>
<li><span class="math inline">\(\text{Number Survived}\)</span> is the number of critters surviving translocation</li>
<li><span class="math inline">\(\text{Number Translocated}\)</span> is the number of critters translocated</li>
<li><span class="math inline">\(p\)</span> is the probability of success (i.e., survival)</li>
</ul>
<p>So in this case we are assuming the number of survivals is binomially distributed.</p>
</div>
<div id="fitting-the-model-to-data" class="section level4">
<h4>Fitting the model to data</h4>
<p>Now things get a little funky here we need to input 2 dependent variables into the model. Well based off the model above I bet it is the number that survived and the total number transported. Let’s give that a shot. We can combine them using the <code>cbind()</code> function.</p>
<pre class="r"><code>fit&lt;-glm(cbind(n_survived,n_translocated)~temperature+truck+temperature:truck,
    data=dat, 
    family=&quot;binomial&quot;)</code></pre>
<p>Now that we have the model fit we can extract fitted and residual values just like we did for the linear model. Don’t believe me? Well here we go.</p>
<pre class="r"><code>dat$pred&lt;- fitted(fit) # get the fitted values</code></pre>
<p>Now we have to get the observed values. In this examples it is the proportion of fish that survived. We need to calculate that as the number survived divided by the number translocated.</p>
<pre class="r"><code>dat$p&lt;- dat$n_survived/dat$n_translocated</code></pre>
<p>We can also extract the residuals of to fitted model.</p>
<pre class="r"><code>dat$resids&lt;- resid(fit)</code></pre>
<p>Let’s do some due diligence and look at some plots just to make sure things look OK. Keep in mind that when dealing with discrete distributions like the binomial things get a bit tricky. So we evaluate the predicted proportion surviving that were predicted and observed.</p>
<pre class="r"><code>plot(resids~pred,dat,
    xlab=&quot;Predicted survival&quot;,
    ylab=&quot;Residual&quot;,
    las=1)</code></pre>
<p><img src="Class-11_files/figure-html/unnamed-chunk-43-1.png" width="672" /></p>
<p>That looks ok to me…</p>
<pre class="r"><code>plot(p~pred,data=dat,
    xlab=&quot;Predicted survival&quot;,
    ylab=&quot;Observed survival&quot;,
    las=1)
abline(0,1)</code></pre>
<p><img src="Class-11_files/figure-html/unnamed-chunk-44-1.png" width="672" /></p>
<p>That does not look ok to me. What the heck is going on? Well, turns out the glm function wants the dependent variable to be <code>c(successes,failures)</code> and not <code>c(successes,total)</code>. Let’s fix that and see if makes things better. Ok. Here goes.</p>
<pre class="r"><code>dat$n_mortalities&lt;- dat$n_translocated-dat$n_survived
fit&lt;-glm(cbind(n_survived,n_mortalities)~temperature+truck+temperature:truck,
    data=dat, family=&quot;binomial&quot;)
dat$pred&lt;- fitted(fit)
dat$p&lt;- dat$n_survived/dat$n_translocated
dat$resids&lt;- resid(fit)</code></pre>
<p>Just like we did before we can plot the residuals.</p>
<pre class="r"><code>plot(resids~pred,dat,
    xlab=&quot;Predicted survival&quot;,
    ylab=&quot;Residual&quot;,
    las=1)</code></pre>
<p><img src="Class-11_files/figure-html/unnamed-chunk-46-1.png" width="672" /></p>
<p>They look good. Now we can plot the probability of surviving versus the predicted probability.</p>
<pre class="r"><code>plot(p~pred,data=dat,
    xlab=&quot;Predicted survival&quot;,
    ylab=&quot;Observed survival&quot;,
    las=1)
abline(0,1)</code></pre>
<p><img src="Class-11_files/figure-html/unnamed-chunk-47-1.png" width="672" /> Oh that is much better!</p>
</div>
<div id="prediction-and-uncertainty" class="section level4">
<h4>Prediction and uncertainty</h4>
<p>Recall that the statistical model for the binomial distribution was</p>
<p><span class="math display">\[Y_i \sim Binomial(N,p)\]</span></p>
<p>where,</p>
<ul>
<li><span class="math inline">\(N\)</span> is the number of trials (i.e., critters)</li>
<li><span class="math inline">\(p\)</span> is the probability of success (i.e., survival), and</li>
<li><span class="math inline">\(Y_i\)</span> is the observed number surviving.</li>
</ul>
<p>Well we can start to make predictions of likely outcomes from that model given how many critters to translocate (<span class="math inline">\(N\)</span>) and the probability of survival (<span class="math inline">\(p\)</span>).</p>
<pre class="r"><code>pdat&lt;- data.frame(temperature=10, 
    truck=levels(dat$truck))</code></pre>
<p>Now let’s see if we can get prediction intervals like we did for the our linear model!</p>
<pre class="r"><code>plink&lt;-predict(fit,pdat,type=&quot;link&quot;, interval=&quot;prediction&quot;)
presponse&lt;-predict(fit,pdat,type=&quot;response&quot;, interval=&quot;prediction&quot;)</code></pre>
<p>Well that ran without any warnings. Let’s look at them.</p>
<pre class="r"><code>head(plink)</code></pre>
<pre><code>##          1          2 
## -0.8184927 -0.8019998</code></pre>
<pre class="r"><code>head(presponse)</code></pre>
<pre><code>##         1         2 
## 0.3060837 0.3095979</code></pre>
<p>Boooo, no prediction intervals…. Well that is because prediction intervals are not supported for <code>glm()</code> in R. This is in part due to the difficult nature of constructing an interval for a discrete outcome and the links involved to make the prediction. But it did give us predictions of the expected survival which is nice. Lets see what is going on there in a bit more detail.</p>
<p>We can reconstruct the predictions of we exact the coefficients and use those to estimate the survival. In this example the effect of truck is a ‘dummy’ variable where truck 1 is equal to 0 and truck 2 is equal to 1. So if we plug and play we can get the predicted survival for translocating truck 1 and truck 2 of the temperature is 10 as follows.</p>
<pre class="r"><code>betas&lt;- coef(fit)
temp&lt;- 10
tr1_est&lt;- betas[1]+ betas[2]*temp + betas[3]*0 + betas[4]*0*temp
tr2_est&lt;- betas[1]+ betas[2]*temp + betas[3]*1 + betas[4]*1*temp</code></pre>
<p>Cool beans<a href="https://youtu.be/vc7VBVpl1SY">1</a>. Let’s look at our predicted values.</p>
<pre class="r"><code>tr1_est</code></pre>
<pre><code>## (Intercept) 
##  -0.8184927</code></pre>
<pre class="r"><code>tr2_est</code></pre>
<pre><code>## (Intercept) 
##  -0.8019998</code></pre>
<p>That is weird, I was expecting the values to be somewheres between 0 and 1. Well we have to apply our link function. In the specification above we used the logit link to make a probability a value that is not constrained to live between 0 and 1. Similarly we can use the expit function to transform a value to something that is bounded between 0 and 1. Logit and expit are related functions. The expit function is:</p>
<p><span class="math display">\[p = \frac{exp(y)}{1+exp(y)}\]</span></p>
<p>whereas the logit function is</p>
<p><span class="math display">\[y = log(\frac{p}{1-p}).\]</span></p>
<p>Let’s confirm that is the case.</p>
<pre class="r"><code>tr1_S&lt;- exp(tr1_est)/(1+exp(tr1_est))# expit function
tr2_S&lt;- exp(tr2_est)/(1+exp(tr2_est))# expit function
tr1_S</code></pre>
<pre><code>## (Intercept) 
##   0.3060837</code></pre>
<pre class="r"><code>tr2_S</code></pre>
<pre><code>## (Intercept) 
##   0.3095979</code></pre>
<p>Ok. That all seemed to work. Lets try to convert <code>tr1_S</code> and <code>tr2_S</code> to log odds using the logit link.</p>
<pre class="r"><code>try1&lt;- log(tr1_S/(1-tr1_S))
tr1_est</code></pre>
<pre><code>## (Intercept) 
##  -0.8184927</code></pre>
<pre class="r"><code>try1 # should be close, within rounding error</code></pre>
<pre><code>## (Intercept) 
##  -0.8184927</code></pre>
<p>Let’s do the estimate for truck 2</p>
<pre class="r"><code>try2&lt;- log(tr2_S/(1-tr2_S))
tr2_est</code></pre>
<pre><code>## (Intercept) 
##  -0.8019998</code></pre>
<pre class="r"><code>try2 # should be close, within rounding error</code></pre>
<pre><code>## (Intercept) 
##  -0.8019998</code></pre>
<p>Cool, those functions are going to be really important. Be sure to remember that function <code>exp(y)/(1+exp(y))</code>! It is the basis for most capture recapture and occupancy models!</p>
<p>Now that we have a prediction of survival form our model we can estimate what the likely outcomes would be if we needed to translocate 100 critters and the temperature was 10.</p>
<p>The easiest way to think about the expected outcomes if you are not really good at probability is to simply simulate the potential outcomes and confirm for yourself. Fortunately <code>R</code> and a builtin in function for simulating from a binomial distribution <code>rbinom()</code> and all you have to specify for inputs are the number of simulations to make, the number of trials, and the probability of success.</p>
<p>First we will specify the number of trials, number of critters to translocate in this case.</p>
<pre class="r"><code>translocate&lt;- 100 # num. critters to translocate</code></pre>
<p>Now we can tell the <code>rbinom()</code> function how many simulations to make. We will go for 100000. Any large number will do to make sure you capture all the possible outcomes.</p>
<pre class="r"><code>outcomes&lt;- rbinom(100000,translocate, tr1_S)</code></pre>
<p>Let’s look at the outcomes to make sure things are right. It should be a vector with 100k elements in it.</p>
<pre class="r"><code>length(outcomes)</code></pre>
<pre><code>## [1] 100000</code></pre>
<p>Things look good. Now if we tabulate up the frequency of the outcomes we can get an idea of the uncertainty. The <code>table()</code> function will take a vector and count up the unique outcomes.</p>
<pre class="r"><code>N_survive&lt;-table(outcomes)
N_survive</code></pre>
<pre><code>## outcomes
##   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26 
##    1    1   11   27   38   82  168  362  586  886 1490 2302 3237 4197 5295 
##   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41 
## 6537 7332 8253 8629 8506 8160 7475 6458 5434 4211 3314 2457 1661 1114  726 
##   42   43   44   45   46   47   48   49   50   51   53 
##  469  260  164   74   40   24    6    9    2    1    1</code></pre>
<p>We can also look at a histogram of the outcomes.</p>
<pre class="r"><code>hist(outcomes)</code></pre>
<p><img src="Class-11_files/figure-html/unnamed-chunk-60-1.png" width="672" /></p>
<p>And we can calculate the probability of each outcome by summing the how many simulations we drew and dividing the frequency by the total.</p>
<pre class="r"><code>N_survive_p&lt;-N_survive/sum(N_survive)</code></pre>
<p>I need to note that these are conditional probabilities. They give the probability of specific outcomes conditional on the inputs, number of critters to transport, truck, and temperature in this case. For this example the outcomes are conditional on temperature being 10, truck 1 being used, and 100 critters being translocated. Overall, they should sum to 1 as this is all the possible outcomes. Let’s check to make sure.</p>
<pre class="r"><code>sum(N_survive_p)# check to see if it sums to 1</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Yep, it does.</p>
<p>We could enter those values into a decision Model as the possible outcomes for using truck 1</p>
<p>We can use these values to quantify risk. For example what is the probability of mortality exceeding 35 critters? First we can count up how many of our simulations had a mortality exceeding 35 critters using the <code>length()</code> function. The <code>length()</code> function takes a vector and returns how many elements are in it.</p>
<pre class="r"><code>grt35&lt;- length(outcomes[outcomes&gt;35])</code></pre>
<p>Now if we divide that by the number of simulations we did then we get the probability of that outcome occurring.</p>
<pre class="r"><code>grt35/length(outcomes)</code></pre>
<pre><code>## [1] 0.14533</code></pre>
</div>
<div id="incorporating-outcomes-and-decisions" class="section level4">
<h4>Incorporating outcomes and decisions</h4>
<p>We can take our conditional probabilities and put them directly into a decision model. More on that later in the semester.</p>
<p>An we can use R to figure out what all the conditional probabilities would be for the network above. First we need to make all the possible combinations of states we have in our network.</p>
<pre class="r"><code>combos&lt;- expand.grid(
    temperature=c(8,10,12,14),
    ntranslocate=c(100,250,500,1000),
    truck=c(&quot;truck 1&quot;,&quot;truck 2&quot;))</code></pre>
<p>Then we need to get the survival estimate from our fitted model.</p>
<pre class="r"><code>combos$S&lt;- predict(fit,combos,type=&quot;response&quot;)
head(combos)</code></pre>
<pre><code>##   temperature ntranslocate   truck         S
## 1           8          100 truck 1 0.2978275
## 2          10          100 truck 1 0.3060837
## 3          12          100 truck 1 0.3144663
## 4          14          100 truck 1 0.3229716
## 5           8          250 truck 1 0.2978275
## 6          10          250 truck 1 0.3060837</code></pre>
<p>Now we just need to tabulate all the expected outcomes for each expected survival in the <code>combos</code> data.frame. Let’s see just how many combinations we have to evaluate.</p>
<pre class="r"><code>nrow(combos)</code></pre>
<pre><code>## [1] 32</code></pre>
<p>Whoa, that is a lot, remember that curse of dimensionality I talked about earlier in the semester?</p>
<p>Next class we will go over how to deal with getting all the possible outcomes and further dealing with this problem!</p>
</div>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
