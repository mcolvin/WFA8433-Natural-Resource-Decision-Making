<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="site_libs/highlight/textmate.css"
      type="text/css" />
<script src="site_libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>

<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.0/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.9em;
  padding-left: 5px;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Course home</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Course information
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="index.html">Course home</a>
    </li>
    <li>
      <a href="syllabus.html">Course Syllabus</a>
    </li>
    <li>
      <a href="course-overview.html">Course Overview</a>
    </li>
    <li>
      <a href="final-project.html">About final project</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Classes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Class-01.html">Class 1: Introduction to decision making</a>
    </li>
    <li>
      <a href="Class-02.html">Class 2: The PrOACT Process</a>
    </li>
    <li>
      <a href="Class-03.html">Class 3: Uncertainty and decision making</a>
    </li>
    <li>
      <a href="Class-04.html">Class 4: Decision trees and nets</a>
    </li>
    <li>
      <a href="Class-05.html">Class 5: Intro to SDM and ARM</a>
    </li>
    <li>
      <a href="Class-06.html">Class 6: Structuring and quantifying objectives</a>
    </li>
    <li>
      <a href="Class-07.html">Class 7: Structuring objectives</a>
    </li>
    <li>
      <a href="Class-08.html">Class 8: Intro to R</a>
    </li>
    <li>
      <a href="Class-09.html">Class 9: Linear Models</a>
    </li>
    <li>
      <a href="Class-10.html">Class 10: LMs and GLMs</a>
    </li>
    <li>
      <a href="Class-11.html">Class 11: Prediction and GLMs</a>
    </li>
    <li>
      <a href="Class-12.html">Class 12: GLMs continued</a>
    </li>
    <li>
      <a href="Class-13.html">Class 13: Poissons</a>
    </li>
    <li>
      <a href="Class-14.html">Class 14: HLMs</a>
    </li>
    <li>
      <a href="Class-15.html">Class 15: HLMs and occupancy</a>
    </li>
    <li>
      <a href="Class-16.html">Class 16: Occupancy continued</a>
    </li>
    <li>
      <a href="Class-17.html">Class 17: Influence diagrams, Sensitivity analyses &amp; N-Mixtures</a>
    </li>
    <li>
      <a href="Class-18.html">Class 18: N-Mixtures &amp; Estimating abundance</a>
    </li>
    <li>
      <a href="Class-19.html">Class 19: Population dynamics and decisions</a>
    </li>
    <li>
      <a href="Class-20.html">Class 20</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Assignments
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="hw-01.html">Homework 1</a>
    </li>
    <li>
      <a href="hw-02.html">Homework 2</a>
    </li>
    <li>
      <a href="hw-03.html">Homework 3</a>
    </li>
    <li>
      <a href="hw-04.html">Homework 4</a>
    </li>
    <li>
      <a href="hw-05.html">Homework 5</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Additional Resources
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="R-tutorials.html">R tutorials</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<p><!--


rmarkdown::render_site("Class-20.Rmd")# build website

source("_build.R")
build("Class-20",bld="PAGE",docs=TRUE) # bld = PAGE,ENTIRE,SCRIPT

# PURL THIS SHIT & MOVE FILES TO DOCS
build("Class-20",bld="SCRIPT",docs=TRUE) # bld = PAGE,ENTIRE,SCRIPT

source("_build.R");build("Class-20",bld="PAGE",docs=TRUE)# bld = PAGE,ENTIRE,SCRIPT

--></p>
<p><img src="media/banner-07.jpg" width="100%" /></p>
<div id="class-20" class="section level1 unnumbered">
<h1>Class 20</h1>
</div>
<div id="class-preliminaries" class="section level1">
<h1><span class="header-section-number">1</span> Class preliminaries</h1>
<ul>
<li>Supplemental background reading for next class(es): <!--
********** add some reading
--></li>
<li>Reading(s) for next time:
<ul>
<li>Tyre, A. J., J. T. Peterson, S. J. Converse, T. Bogich, D. Miller, M. Post van der Burg, C. Thomas, R. Thompson, J. Wood, D. C. Brewer, and M. C. Runge. 2011. Adaptive Management of Bull Trout Populations in the Lemhi Basin. Journal of Fish and Wildlife Management 2:262-281. <a href="pdfs/T78.pdf">PDF</a></li>
</ul></li>
<li>Class project: Be developing your decision model</li>
<li>Final exam period-April 28th at 3pm.</li>
<li>Link to class recording <a href="">YouTube</a></li>
<li>Today’s R script <a href="scripts/Class-20.R">Class-20.R</a></li>
</ul>
<div id="class-overview-objectives" class="section level2">
<h2><span class="header-section-number">1.1</span> Class overview &amp; objectives</h2>
<p>The objectives of this class are to:</p>
<ol style="list-style-type: decimal">
<li>Increase understanding of decision model parameterization</li>
<li>Address how to deal with large parameter spaces</li>
<li>Address structural uncertainty in decision making</li>
<li>Evaluate decision by Monte Carlo</li>
<li>Introduction to optimization</li>
</ol>
</div>
<div id="getting-ready-to-go" class="section level2">
<h2><span class="header-section-number">1.2</span> Getting ready to go</h2>
<ul>
<li>Netica file:
<ul>
<li><a href="pig.neta">Pigs</a></li>
<li><a href="pig-with-decisions.neta">Pigs 2</a></li>
<li><a href="pig-with-decisions-and-struct-uncertainty.neta">Pigs 3</a></li>
</ul></li>
<li>Data files:
<ul>
<li><a href="trout-stocking.csv">Urban trout</a></li>
</ul></li>
<li>Install libraries that we have not used yet.</li>
</ul>
<pre class="r"><code>#install.packages(&quot;adagio&quot;)</code></pre>
</div>
</div>
<div id="population-dynamics-decisions-continued" class="section level1">
<h1><span class="header-section-number">2</span> Population dynamics &amp; decisions continued</h1>
<div id="overview" class="section level2">
<h2><span class="header-section-number">2.1</span> Overview</h2>
<p>In this class we will continue with the pig decision network we started last class. One of the issues we started to see last class was there were some combinations in our conditional probability tables that were a bit sparse. Specifically, because we were using Poisson distribution on the initial values. One way around this issue is to use a random uniform distribution to ensure you cover all the parameter space. But you may be thinking this might not accurately represent the initial conditions, but it is OK Netica takes care of it.</p>
<p>First let’s set up our simulation again.</p>
<pre class="r"><code>F_j=c(0.13,0.56,1.64)# poor, intermediate, good
F_y=c(0.56,0.94,1.93)
F_a =c(1.64,1.76,2.29)
        
S_j=c(0.25,0.31,0.58)
S_y=c(0.31,0.40,0.66)
S_a =c(0.58,0.60,0.71)       

set.seed(8433)
reps&lt;- 250000
outcomes&lt;- data.frame(
    condition=sample(c(1:3),reps,replace=TRUE),
    n0_j=round(runif(reps,25,175),0),
    n0_y=round(runif(reps,0,50),0),
    n0_a=round(runif(reps,0,100),0)) 

outcomes$n1_j&lt;-rpois(reps,outcomes$n0_j*F_j[outcomes$condition])+
    rpois(reps,outcomes$n0_y*F_y[outcomes$condition])+
    rpois(reps,outcomes$n0_a*F_a[outcomes$condition])
outcomes$n1_y&lt;- rbinom(reps,outcomes$n0_j,S_j[outcomes$condition])  
outcomes$n1_a&lt;- rbinom(reps,outcomes$n0_y,S_y[outcomes$condition])+
    rbinom(reps,outcomes$n0_a,S_a[outcomes$condition])</code></pre>
<p>The major difference in the code above is the use of the <code>runif()</code> and the <code>round()</code> function to sample across the possible combinations of initial abundances of juveniles, yearlings, and adults. Now we can use the <code>cut()</code> function to discretize our outcomes.</p>
<pre class="r"><code># Juveniles Initial Abundance
bins&lt;- seq(0,175,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n0_j_bin&lt;-cut(outcomes$n0_j,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)
# Juveniles Future Abundance
bins&lt;- seq(0,650,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_j_bin&lt;-cut(outcomes$n1_j,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE) 
# Yearling Initial Abundance
bins&lt;- seq(0,50,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1], sep = &quot;-&quot;)
outcomes$n0_y_bin&lt;- cut(outcomes$n0_y,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)
# Yearling Future  Abundance
bins&lt;- seq(0,200,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_y_bin&lt;- cut(outcomes$n1_y,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE) 
# Adult Initial Abundance
bins&lt;- seq(0,100,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n0_a_bin&lt;- cut(outcomes$n0_a,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)  
# Adult Future  Abundance
bins&lt;- seq(0,200,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_a_bin&lt;- cut(outcomes$n1_a,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)</code></pre>
<p>Whoa, that is done, what a bit of work to discretize all those values of future abundance.</p>
<p>Now we can use the <code>dcast()</code> function again to summarize the frequencies and calculate the conditional probabilities of the outcomes.</p>
<pre class="r"><code>library(reshape2) # for the dcast function</code></pre>
<pre><code>## Warning: package &#39;reshape2&#39; was built under R version 3.1.3</code></pre>
<pre class="r"><code>outcomes$tmp&lt;-1 # a value to sum over for counts

future_juveniles&lt;- dcast(data=outcomes, 
    formula=n0_j_bin+n0_y_bin+n0_a_bin+condition~n1_j_bin,
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)  
    
future_yearlings&lt;- dcast(data=outcomes, 
    formula=n0_j_bin+condition~n1_y_bin,
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)  
    
future_adults&lt;- dcast(data=outcomes, 
    formula=n0_a_bin+n0_j_bin+condition~n1_a_bin, 
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)    </code></pre>
<p>Using the <code>prop.table()</code> function we ca get the relative frequency, probabilities for each outcomes within each combination of nodes influencing future abundance.</p>
<pre class="r"><code>future_juveniles[,-c(1:4)]&lt;- prop.table(
    as.matrix(future_juveniles[,-c(1:4)]),
    margin=1)
future_yearlings[,-c(1,2)]&lt;- prop.table(
    as.matrix(future_yearlings[,-c(1,2)]),
    margin=1)
future_adults[,-c(1:3)]&lt;- prop.table(
    as.matrix(future_adults[,-c(1:3)]),
    margin=1)</code></pre>
<p>Now we can save those values as a <code>*.csv</code> to easily copy and paste those values into the conditional probability tables for future abundance notes.</p>
<pre class="r"><code>write.csv(future_juveniles,&quot;future_juveniles.csv&quot;)
write.csv(future_yearlings,&quot;future_yearlings.csv&quot;)
write.csv(future_adults,&quot;future_adults.csv&quot;)</code></pre>
<p>Only 2 things lacking right now, we need a utility and some decisions to evaluate.</p>
<div id="decisions" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Decisions</h3>
<p>The original paper suggested using hunting to control the population. Suppose managers proposed that it would be feasible to harvest adults only, all life stages, and No harvest at the rates below:</p>
<ul>
<li>Harvest adults only: 5, 10, and 15%</li>
<li>Harvest all life stages: 5, 10, and 15%</li>
<li>No harvest: 0%</li>
</ul>
<p>The harvest will influence the future abundance of each stage so we need to account for that in our simulaton of the outcomes.</p>
<pre class="r"><code>F_j=c(0.13,0.56,1.64)# poor, intermediate, good
F_y=c(0.56,0.94,1.93)
F_a =c(1.64,1.76,2.29)
        
S_j=c(0.25,0.31,0.58)
S_y=c(0.31,0.40,0.66)
S_a =c(0.58,0.60,0.71)       

set.seed(8433)
reps&lt;- 250000
outcomes&lt;- data.frame(
    condition=sample(c(1:3),reps,replace=TRUE),
    n0_j=round(runif(reps,25,175),0),
    n0_y=round(runif(reps,0,50),0),
    n0_a=round(runif(reps,0,100),0),
    decision=sample(c(1:7),reps,replace=TRUE)) </code></pre>
<p>The set up is similar to the code before but we are adding a matrix of harvest values. It is set up so a row represents a decision alternative, 1:7, for each life stage as columns.</p>
<pre class="r"><code>harvest_matrix&lt;- matrix(0,nrow=7, ncol=3)
harvest_matrix[1,] &lt;- c(0,0,0.05) 
harvest_matrix[2,] &lt;- c(0,0,0.10)   
harvest_matrix[3,] &lt;- c(0,0,0.15)   
harvest_matrix[4,] &lt;- c(0.05,0.05,0.05)  
harvest_matrix[5,] &lt;- c(0.05,0.05,0.05)   
harvest_matrix[6,] &lt;- c(0.05,0.05,0.05)   
harvest_matrix[7,] &lt;- c(0.00,0.00,0.00)  </code></pre>
<p>Now we can use the harvest matrix values with the condition dependent survival rate to simulate the number of juveniles.</p>
<pre class="r"><code>outcomes$n1_j&lt;-rpois(reps,rbinom(reps,outcomes$n0_j,1-harvest_matrix[outcomes$decision,1])*F_j[outcomes$condition])+
    rpois(reps,rbinom(reps,outcomes$n0_y,1-harvest_matrix[outcomes$decision,2])*F_y[outcomes$condition])+
    rpois(reps,rbinom(reps,outcomes$n0_a,1-harvest_matrix[outcomes$decision,3])*F_a[outcomes$condition])</code></pre>
<p>And we can simulate the yearlings and adults.</p>
<pre class="r"><code>outcomes$n1_y&lt;- rbinom(reps,outcomes$n0_j,1-harvest_matrix[outcomes$decision,1]*S_j[outcomes$condition])  
outcomes$n1_a&lt;- rbinom(reps,outcomes$n0_y,1-harvest_matrix[outcomes$decision,2]*S_y[outcomes$condition])+
    rbinom(reps,outcomes$n0_a,1-harvest_matrix[outcomes$decision,3]*S_a[outcomes$condition])</code></pre>
<p>Now, same as before we can bin up the initial values and future values for juveniles, yearlings and adults.</p>
<pre class="r"><code># Juveniles Initial Abundance
bins&lt;- seq(0,175,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n0_j_bin&lt;-cut(outcomes$n0_j,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)
# Juveniles Future Abundance
bins&lt;- seq(0,650,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_j_bin&lt;-cut(outcomes$n1_j,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE) 
# Yearling Initial Abundance
bins&lt;- seq(0,50,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1], sep = &quot;-&quot;)
outcomes$n0_y_bin&lt;- cut(outcomes$n0_y,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)
# Yearling Future  Abundance
bins&lt;- seq(0,200,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_y_bin&lt;- cut(outcomes$n1_y,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE) 
# Adult Initial Abundance
bins&lt;- seq(0,100,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n0_a_bin&lt;- cut(outcomes$n0_a,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)  
# Adult Future  Abundance
bins&lt;- seq(0,200,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_a_bin&lt;- cut(outcomes$n1_a,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)</code></pre>
<p>And we can then calculate the frequency of each outcome and calculate the conditional probabilities.</p>
<pre class="r"><code>library(reshape2) # for the dcast function
outcomes$tmp&lt;-1 # a value to sum over for counts

future_juveniles&lt;- dcast(data=outcomes, 
    formula=n0_j_bin+n0_y_bin+n0_a_bin+condition+decision~n1_j_bin,
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)  
    
future_yearlings&lt;- dcast(data=outcomes, 
    formula=n0_j_bin+condition+decision~n1_y_bin,
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)  
    
future_adults&lt;- dcast(data=outcomes, 
    formula=n0_a_bin+n0_j_bin+condition+decision~n1_a_bin, 
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)    

future_juveniles[,-c(1:5)]&lt;- prop.table(as.matrix(future_juveniles[,-c(1:5)]),1)
future_yearlings[,-c(1:3)]&lt;- prop.table(as.matrix(future_yearlings[,-c(1:3)]),1)
future_adults[,-c(1:4)]&lt;- prop.table(as.matrix(future_adults[,-c(1:4)]),1)</code></pre>
<p>And save them for copy and pasting into the conditional probability tables.</p>
<pre class="r"><code>write.csv(future_juveniles,&quot;future_juveniles-with-decisions.csv&quot;)
write.csv(future_yearlings,&quot;future_yearlings-with-decisions.csv&quot;)
write.csv(future_adults,&quot;future_adults-with-decisions.csv&quot;)</code></pre>
<p>Now we can add those tables to the <a href="pig-with-decisions.neta">Pigs 2</a> network which now has a decision node and a utility that calculates the population abundance. Let’s explore this.</p>
</div>
</div>
<div id="structural-uncertainty" class="section level2">
<h2><span class="header-section-number">2.2</span> Structural uncertainty</h2>
<p>Ok, we talked previously about various sources of uncertainty and we added some parametric uncertainty by making use of <code>rpois()</code> and <code>rbinom()</code> to calculate the conditional probabilities. One of the other uncertainties we can deal with include observation and structural. We will learn a bit about structural uncertainty here.</p>
<p>What do we mean by structural uncertainty? Well structural uncertainty is where we do have complete understanding of the underlying process. How does this apply to our pig example? Well we are applying harvest as a potential way to control the population and the application of this harvest mortality may be additive or compensatory. Specifically, additive morality is simply the condition and stage specific survival times the harvest rate. A compensatory rate allows condition and stage specific survival to remain constant in the presence of additional harvest mortality (i.e., doomed surplus), at least until harvest mortality exceeds natural mortality.</p>
<p>Let’s visualize this real quick. Suppose we have a baseline survival of 0.8 and we are evaluating a harvest rate varying from 0 to 1.</p>
<pre class="r"><code>S&lt;- 0.8
H&lt;- seq(0,1,by=0.01)

# additive
S_add&lt;- S*(1-H)

# compensatory
C&lt;- 1-S
b&lt;-ifelse(H &gt; C,1,0)
S_comp&lt;-ifelse (H &gt; C, (S*(1-b*H))/(1-C), S*(1-b*H))

# plot results
plot(x=H,y=S_add,
    xlab=&quot;Harvest rate&quot;,
    ylab=&quot;Survival rate&quot;,
    type=&#39;l&#39;,
    lty=1)
points(x=H,y=S_comp,type=&#39;l&#39;,lty=2)
legend(&quot;topright&quot;,c(&quot;Addtive&quot;,&quot;Compensatory&quot;),
    lty=c(1,2))</code></pre>
<p><img src="Class-20_files/figure-html/unnamed-chunk-15-1.png" width="672" /> The setup is the same as before to generate the possible outcomes.</p>
<pre class="r"><code>F_j=c(0.13,0.56,1.64)# poor, intermediate, good
F_y=c(0.56,0.94,1.93)
F_a =c(1.64,1.76,2.29)
        
S_j=c(0.25,0.31,0.58)
S_y=c(0.31,0.40,0.66)
S_a =c(0.58,0.60,0.71)       

set.seed(8433)
reps&lt;- 500000
outcomes&lt;- data.frame(
    condition=sample(c(1:3),reps,replace=TRUE),
    n0_j=round(runif(reps,25,175),0),
    n0_y=round(runif(reps,0,50),0),
    n0_a=round(runif(reps,0,100),0),
    decision=sample(c(1:7),reps,replace=TRUE),
    mortalityType=sample(c(1:2),reps,replace=TRUE))# 1 add, 2 pc, 3, comp</code></pre>
<p>Now we add the matrix of decisions</p>
<pre class="r"><code>harvest_matrix&lt;- matrix(0,nrow=7, ncol=3)
harvest_matrix[1,] &lt;- c(0,0,0.05) 
harvest_matrix[2,] &lt;- c(0,0,0.10)   
harvest_matrix[3,] &lt;- c(0,0,0.15)   
harvest_matrix[4,] &lt;- c(0.05,0.05,0.05)  
harvest_matrix[5,] &lt;- c(0.10,0.10,0.10)   
harvest_matrix[6,] &lt;- c(0.15,0.15,0.15)   
harvest_matrix[7,] &lt;- c(0.00,0.00,0.00)  </code></pre>
<p>Now here is where it gets a bit different, we need to take the condition and stage specific baseline survivals that will be adjusted depending on whether harvest mortality is additive or compensatory.</p>
<p>Here goes for juveniles.</p>
<pre class="r"><code># BASELINE SURVIVAL FOR JUVENILES
outcomes$S_j&lt;- S_j[outcomes$condition]# condition specific survival

## ADDITIVE
indx_add&lt;- which(outcomes$mortalityType==1)
outcomes[indx_add,]$S_j&lt;-outcomes[indx_add,]$S_j*(1-harvest_matrix[outcomes[indx_add,]$decision,3])

## COMPENSATORY
indx_c&lt;- which(outcomes$mortalityType==2)
C&lt;- 1-outcomes[indx_c,]$S_j
H&lt;- harvest_matrix[outcomes[indx_c,]$decision,3]
b&lt;-ifelse(H &gt; C,1,0)
outcomes[indx_c,]$S_j&lt;-ifelse (H &gt; C, 
    (outcomes[indx_c,]$S_j*(1-b*H))/(1-C), 
    outcomes[indx_c,]$S_j*(1-b*H))    </code></pre>
<p>Now we can do it for yearlings.</p>
<pre class="r"><code># BASELINE SURVIVAL FOR YEARLINGS
outcomes$S_y&lt;- S_y[outcomes$condition]# condition specific survival

## ADDITIVE
indx_add&lt;- which(outcomes$mortalityType==1)
outcomes[indx_add,]$S_y&lt;-outcomes[indx_add,]$S_y*(1-harvest_matrix[outcomes[indx_add,]$decision,1])

## COMPENSATORY
indx_c&lt;- which(outcomes$mortalityType==2)
C&lt;- 1-outcomes[indx_c,]$S_y
H&lt;- harvest_matrix[outcomes[indx_c,]$decision,1]
b&lt;-ifelse(H &gt; C,1,0)
outcomes[indx_c,]$S_y&lt;-ifelse (H &gt; C, 
    (outcomes[indx_c,]$S_y*(1-b*H))/(1-C), 
    outcomes[indx_c,]$S_y*(1-b*H))  </code></pre>
<p>And finally, for the adults.</p>
<pre class="r"><code># BASELINE SURVIVAL FOR ADULTS
outcomes$S_a&lt;- S_a[outcomes$condition]# condition specific survival

## ADDITIVE
indx_add&lt;- which(outcomes$mortalityType==1)
outcomes[indx_add,]$S_a&lt;-outcomes[indx_add,]$S_a*(1-harvest_matrix[outcomes[indx_add,]$decision,1])

## COMPENSATORY
indx_c&lt;- which(outcomes$mortalityType==2)
C&lt;- 1-outcomes[indx_c,]$S_a
H&lt;- harvest_matrix[outcomes[indx_c,]$decision,3]
b&lt;-ifelse(H &gt; C,1,0)
outcomes[indx_c,]$S_a&lt;-ifelse (H &gt; C, 
    (outcomes[indx_c,]$S_a*(1-b*H))/(1-C), 
    outcomes[indx_c,]$S_a*(1-b*H))   </code></pre>
<p>Yeah, we are doing something awesome here. Now we can use our new survivals to simulate the potential outcomes.</p>
<pre class="r"><code>## FUTURE NUMBER OF JUVENILES
outcomes$n1_j&lt;-rpois(reps,rbinom(reps,outcomes$n0_j,outcomes$S_j)*F_j[outcomes$condition])+
    rpois(reps,rbinom(reps,outcomes$n0_y,outcomes$S_y)*F_y[outcomes$condition])+
    rpois(reps,rbinom(reps,outcomes$n0_a,outcomes$S_a)*F_a[outcomes$condition])
## FUTURE NUMBER OF JUVENILES
outcomes$n1_y&lt;- rbinom(reps,outcomes$n0_j,outcomes$S_j)  
## FUTURE NUMBER OF ADULTS
outcomes$n1_a&lt;- rbinom(reps,outcomes$n0_y,outcomes$S_y)+
    rbinom(reps,outcomes$n0_a,outcomes$S_a)</code></pre>
<p>Next up just as before we are going to discrete this thing.</p>
<pre class="r"><code># Juveniles Initial Abundance
bins&lt;- seq(0,175,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n0_j_bin&lt;-cut(outcomes$n0_j,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)
# Juveniles Future Abundance
bins&lt;- seq(0,650,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_j_bin&lt;-cut(outcomes$n1_j,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE) 
# Yearling Initial Abundance
bins&lt;- seq(0,50,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1], sep = &quot;-&quot;)
outcomes$n0_y_bin&lt;- cut(outcomes$n0_y,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)
# Yearling Future  Abundance
bins&lt;- seq(0,200,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_y_bin&lt;- cut(outcomes$n1_y,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE) 
# Adult Initial Abundance
bins&lt;- seq(0,100,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n0_a_bin&lt;- cut(outcomes$n0_a,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)  
# Adult Future  Abundance
bins&lt;- seq(0,200,length.out=5)
labs&lt;- paste(bins[-length(bins)],bins[-1],sep=&quot;-&quot;)
outcomes$n1_a_bin&lt;- cut(outcomes$n1_a,
    breaks=bins,
    labels=labs,
    include.lowest=TRUE)</code></pre>
<p>Now we can discretize, we just need to be sure that we add the mortality type to the frequency table.</p>
<pre class="r"><code>library(reshape2) # for the dcast function
outcomes$tmp&lt;-1 # a value to sum over for counts

future_juveniles&lt;- dcast(data=outcomes, 
    formula=n0_j_bin+n0_y_bin+n0_a_bin+condition+decision+mortalityType~n1_j_bin,
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)  
    
future_yearlings&lt;- dcast(data=outcomes, 
    formula=n0_j_bin+condition+decision+mortalityType~n1_y_bin,
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)  
    
future_adults&lt;- dcast(data=outcomes, 
    formula=n0_a_bin+n0_j_bin+condition+decision+mortalityType~n1_a_bin, 
    value.var=&quot;tmp&quot;,
    fun.aggregate=sum,
    drop=FALSE)    

future_juveniles[,-c(1:6)]&lt;- prop.table(as.matrix(future_juveniles[,-c(1:6)]),1)
future_yearlings[,-c(1:4)]&lt;- prop.table(as.matrix(future_yearlings[,-c(1:4)]),1)
future_adults[,-c(1:5)]&lt;- prop.table(as.matrix(future_adults[,-c(1:5)]),1)</code></pre>
<p>And we can save our conditional probabilities to copy and paste to the decision network.</p>
<pre class="r"><code>write.csv(future_juveniles,&quot;future_juveniles-with-decisions-and-su.csv&quot;)
write.csv(future_yearlings,&quot;future_yearlings-with-decisions-and-su.csv&quot;)
write.csv(future_adults,&quot;future_adults-with-decisions-and-su.csv&quot;)</code></pre>
<p>We can now take these new results and use them to parameterize our decision network with this new bit of structural uncertainty. Exciting right! This new file is <a href="pig-with-decisions-and-struct-uncertainty.neta">here</a>.</p>
</div>
<div id="optimal-decisions" class="section level2">
<h2><span class="header-section-number">2.3</span> Optimal decisions</h2>
<div id="using-monte-carlo-simulation" class="section level3">
<h3><span class="header-section-number">2.3.1</span> Using Monte Carlo Simulation</h3>
<p>The use of tools like Bayesian Decision Networks can be a bit laborious but they are great tools to visualize the decision. Another way to go about determining the optimal decision is Monte Carlo. The cool thing is that we already did a big Monte Carlo simulation.</p>
<p>All we need to do is calculate our utility like we did in the BDN.</p>
<pre class="r"><code>outcomes$abundance&lt;- outcomes$n1_j+outcomes$n1_y+outcomes$n1_a</code></pre>
<p>We can simply calculate the expected value for each decision given all the uncertainty in current and future abundance, conditions, and mortality type.</p>
<pre class="r"><code>ev&lt;- tapply(outcomes$abundance,outcomes$decision,mean)
ev[which.min(ev)]</code></pre>
<pre><code>##        6 
## 181.0305</code></pre>
<p>The one shortcoming of using Monte Carlo sampling is that it is more difficult to add certainty like we did in the BDN. For example, we need to do a subset by mortality type to evaluate the decision alternatives is we knew with 100% certainty that harvest mortality was addtive or compensatory. Cool beans regardless.</p>
<pre class="r"><code>library(plyr)
outcomes$abundance&lt;- outcomes$n1_j+outcomes$n1_y+outcomes$n1_a
ev_comp&lt;- dcast(outcomes,decision~&quot;ev&quot;,
    value.var=&quot;abundance&quot;,
    subset=.(mortalityType==2),
    fun.aggregate=mean)
ev&lt;- dcast(outcomes,decision~&quot;ev&quot;,
    value.var=&quot;abundance&quot;,
    subset=.(mortalityType==1),
    fun.aggregate=mean)</code></pre>
</div>
</div>
</div>
<div id="optimization" class="section level1">
<h1><span class="header-section-number">3</span> Optimization</h1>
<p>The Monte Carlo simulation is an ad hoc optimization that we used to decide among decision alternatives given uncertainty. Let’s look at a bit of a different but common decision situation. This is a case where we have finite resources but need to make a decision among varying decisions. In this example we will look at rainbow trout stocking as part of an effort to recruit anglers. Here we can read in the data.</p>
<pre class="r"><code>stocking&lt;- read.csv(&quot;trout-stocking.csv&quot;)
head(stocking)</code></pre>
<pre><code>##              lake urbanCenter_km politician troutPrivileges
## 1 Ada Hayden Pond              5          1            6973
## 2           DMACC             10          0            4923
## 3          Petoka             16          0            2993
## 4     Bacon Creek             23          0             543
## 5   Big Lake West             24          0             689
## 6    Prairie Park             32          0            5064
##   consectutiveYearsStocked requested
## 1                        3      5000
## 2                        3      5300
## 3                        1      1000
## 4                        1       800
## 5                        3       750
## 6                        2      1500</code></pre>
<p>In this example district fisheries biologists put in requests for fish to stock in various lakes. But the hitch is there are not enough fish to go around. How do we decide? Well from an agency standpoint, Iowa DNR is interested in their efforts maximizing efforts near urban centers, in areas where trout stamps numbers are high. The other consideration is politically driven, politicians commonly have properties on lakes and when stocking does not occur politicians will usually have words with the Bureau Chief. The other thing that IADNR wants to account for the novelty of the stocking event wearing off. Specifically, trout stamps decline after 3 years of stocking and are better focused elsewhere. We can scale our attributes to a utility that we might be able to optimize. The code below uses a proportional scaling equation to scale these values betweent 0 and 1. We will try use our stocking efforts to maximize our value from stocking.</p>
<pre class="r"><code>propscale&lt;-function(x)
    {
    (x-min(x))/(max(x)-min(x))
    }
stocking$uc_scaled&lt;-propscale(stocking$urbanCenter_km)
stocking$pol_scaled&lt;-propscale(stocking$politician)
stocking$priv_scaled&lt;-propscale(stocking$troutPrivileges)
stocking$stocked_scaled&lt;-1-propscale(stocking$consectutiveYearsStocked)
stocking$U&lt;- (stocking$uc_scaled+stocking$pol_scaled+
    stocking$priv_scaled+stocking$stocked_scaled)/4</code></pre>
<p>From the state resources there are 3 hatcheries with 2000, 3000, and 5500 rainbow trout available for stocking. However 17650 fish were requested but only 10500 available. How do we decide among the requests? Well let’s set up the problem with vectors of fish available and the requests.</p>
<pre class="r"><code>troutAvailable&lt;-c(2000,3000,5500)
fish_we_want &lt;- as.integer(stocking$requested)</code></pre>
<p>We can use a tool called dynamic programming. Dynamic programming is difficult to comprehend and beyond the scope of what we are up to here but the gist is it calculates the local maximum values for each value and then it passes back though the matrix of values to find the combination that maximizes the utility. Fortunately we don’t have to program this in, some good folks have put a package together that will solve this knapsack problem. Essentially, we have objects that have size and value that need to be fitted in a knapsack of limited size. In the case of the trout stocking case we have 3 knapsacks.</p>
<p>First thing to do is call up the <code>adagio</code> package and specify the value as an integer.</p>
<pre class="r"><code>library(adagio)</code></pre>
<pre><code>## Warning: package &#39;adagio&#39; was built under R version 3.1.3</code></pre>
<pre class="r"><code>value&lt;- as.integer(stocking$U*100)</code></pre>
<p>Now we can use the <code>mknapsack()</code> function that returns what fish to take from what hatchery to maximize the utility of stocking.</p>
<pre class="r"><code>solution &lt;- mknapsack(value, fish_we_want, troutAvailable)
solution</code></pre>
<pre><code>## $ksack
##  [1] 0 0 1 2 3 3 1 1 2 3
## 
## $value
## [1] 292
## 
## $btracks
## [1] 0</code></pre>
<pre class="r"><code>stocking$hatchery&lt;- solution$ksack</code></pre>
<p>The solution indicates that all but the first 2 requests can be satisfied. This type of programming will set the stage for using stochastic dynamic programming that will be used in adaptive management.</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
