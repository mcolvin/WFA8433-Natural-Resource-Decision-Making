
---
title: ""
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true   
    collapsed: false
---

 <!--


rmarkdown::render_site("Class-22.Rmd")# build website
library(knitr)
rmarkdown::render_site()# build website

source("_build.R")
build("Class-22",bld="PAGE",docs=TRUE) # bld = PAGE,ENTIRE,SCRIPT

# PURL THIS SHIT & MOVE FILES TO DOCS
build("Class-22",bld="SCRIPT",docs=TRUE) # bld = PAGE,ENTIRE,SCRIPT

source("_build.R");build("Class-21",bld="PAGE",docs=TRUE)# bld = PAGE,ENTIRE,SCRIPT

-->


```{r echo=FALSE, out.width="100%"}
library(knitr)
include_graphics("media/banner-11.jpg")
```


# Class 23: {-}

# Class preliminaries

* Supplemental background reading for next class(es):
<!--
********** add some reading
-->
* Reading(s) for next time:
    * Conroy and Peterson Chapter 7
    * Conroy and Peterson Chapter 9
* Class project: 
    * Be developing your decision model
    * Final exam period-April 28th at 3pm.
* Link to class recording  [YouTube]()
* Today's R script [Class-22.R](scripts/Class-22.R)

## Class overview & objectives 

The objectives of this class are to:

1. Further understanding of Bayes Theorem
2. Formally use monitoring to learn
3. Adapting decisions to learning in adaptive management






# Population dynamics & decisions

## Overview

### Using stochastic dynamic programming


We will create transition matrices by simulating harvest and population 
dynamics note that the way it is set up indicates that the harvest 
decision was based on the spring population before reproduction Also 
note that we are not keeping track of the number of ponds to aid in 
decision making. 





```{r,eval=FALSE, echo=FALSE}
combo<-merge(c(1:15),c(0:4*0.1))
colnames(combo)<-c("N_t","H_t")

H_t<- rep(H_t,500)
N_t<- rep(N_t,500)
## choose harvest mortality model
har_type<-'AMH'
R_t<- 16
P_t <- 2
# KEEP FROM GOING NEGATIVE (equation 10 (Anderson 1975))  
P_t_N=max(0.0001,-2.76+0.391*P_t+0.233*R_t)
#  young production to be added to fall population (equation 2 (Anderson 1975))
Y_t  = 1/((1/(12.48*P_t^0.851))+(0.519/N_t)) 

Y_t <- rtnorm(length(Y_t),Y_t,Y_t*0.3,lower = 1)

# Fall population at time t (equation 5 (Anderson 1975))
F_t	= (0.92*N_t) + Y_t 
harvest<-ifelse(F_t < H_t*F_t,F_t, H_t*F_t)# harvest at time t (need to keep track of this)

# AMH: ADDITIVE MORTALITY
survival_adult_amh<- (1-0.27*exp(2.08*H_t))
survival_young_amh<- (1-0.40*exp(0.67*H_t))

# CMH: COMPENSATORY MORTALITY
survival_adult_cmh<- ifelse(H_t<0.25,0.57,(0.57-1.2*(H_t-0.25)))
survival_young_cmh<-  ifelse(H_t<0.25,0.5,(0.5-1*(H_t-0.25)))

# Pop size after spring migration
# AMH: ADDITIVE MORTALITY
N.t1.amh<- N_t*survival_adult_amh + Y_t*survival_young_amh

# CMH: COMPENSATORY MORTALITY
N.t1.cmh<- N_t*survival_adult_cmh + Y_t*survival_young_cmh

## Weight and add model specific population size estimates
harvest_type<- ifelse(har_type=='AMH', 1, 0)   
N_t_N<- N.t1.amh*harvest_type + N.t1.cmh*(1-harvest_type)


# Discretize population sizes into 3 states
# Could do more classes this is just to simplify
Initial_N<-floor(N_t/5.5)
### prevents new pop states from arising
N_t_N <- ifelse(N_t_N < 1, 1, N_t_N)
End_N <-ifelse(floor(N_t_N/5.5)> 2, 2,floor(N_t_N/5.5)) 

## create a table of transition frequencies that will be turned into 
## state transition probabilities one for each decision alternative
TM<- table(Initial_N,End_N,H_t)

### These are now transition matrices one for each  harvest decision alternative
TM_1 <- prop.table(TM[,,1],1)
TM_2 <- prop.table(TM[,,2],1)
TM_3 <- prop.table(TM[,,3],1)
TM_4 <- prop.table(TM[,,4],1)
TM_5 <- prop.table(TM[,,5],1)


## calculate the average (expected) return for each population
## state / decision alternative combination
Return<-tapply(harvest,list(Initial_N,H_t), mean)


# Set up arrays for solving 
P <- array(0, c(3,3,5))
P[,,1] <- TM_1
P[,,2] <- TM_2
P[,,3] <- TM_3
P[,,4] <- TM_4
P[,,5] <- TM_5
R <- Return

### Library needed for truncated normal
library(msm)
### library needed for SDP
library(MDPtoolbox)

### now find optimal state dependent harvest 
mdp_policy_iteration(P, R, discount=.99999)


######### plot state dependent policies fir current time
x<-unique(states[,1])
y<-unique(states[,2])
z<-matrix(zz[,3], ncol = length(unique(states[,2]))
## create plot of state specific
filled.contour(x,y,z,color.palette=heat.colors,xlab="Number of ducks (100k)",ylab="Number of ponds" )

  
```

-->

